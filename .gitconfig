[branch]
    autosetuprebase = always
[help]
    autocorrect = 1
[color]
    ui = true
    diff = auto
    status = auto
    branch = auto
    interactive = auto
    grep = true
[color "branch"]
    current = green bold
    local   = magenta bold
    remote  = yellow bold
[color "diff"]
    meta = yellow bold
    frag = magenta bold
    old = red
    new = green
    whitespace = white reverse
[diff]
    algorithm = patience
    submodule = log
[log]
    decorate = true
    date = relative
[color "status"]
    added = bold green
    changed = bold red
    untracked = bold cyan
    unmerged = magenta bold
[alias]
    # via http://blog.apiaxle.com/post/handy-git-tips-to-stop-you-getting-fired/
    snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"
    snapshots = !git stash list --grep snapshot
    #via http://stackoverflow.com/questions/5188320/how-can-i-get-a-list-of-git-branches-ordered-by-most-recent-commit
    recent-branches = !git for-each-ref --count=5 --sort=-committerdate refs/heads/ --format='%(refname:short)'
    amend = commit --amend --no-edit   # amend your last commit and don't edit the commit message
    edit = commit --amend --only       # amend your last commit without adding the already staged files

    # amend a specific commit. Example usage: "git add -p; git fixup HEAD~5"
    # OR "git add -p; git stash --keep-index; git fixup HEAD~5; git stash pop"
    # via http://stackoverflow.com/questions/3103589/how-can-i-easily-fixup-a-past-commit
    fixup = "!sh -c '(git diff-files --quiet || (echo Unstaged changes, please commit or stash with --keep-index; exit 1)) && COMMIT=$(git rev-parse $1) && git commit --fixup=$COMMIT && git rebase -i --autosquash $COMMIT~1' -"
    cm = commit -m
    ec = config --global -e
    current-branch = git symbolic-ref -q --short HEAD

    # sync with the remote origin branch given as argument OR with master if no argument is given
    syncbr = !git stash && CURRENT_BRANCH="$(git symbolic-ref -q --short HEAD)" && git pull --rebase --prune origin "${@-$CURRENT_BRANCH}" && git stash pop
    # sync with the upstream remote on the given branch OR with master if no argument is given
    syncupbr = !git stash && CURRENT_BRANCH="$(git symbolic-ref -q --short HEAD)" && TARGET_BRANCH="${@-$CURRENT_BRANCH}" && git checkout "$TARGET_BRANCH" && git pull --rebase --prune upstream "$TARGET_BRANCH" && git stash pop

    # pretty one-line log with tags, branches and authors
    ls = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --decorate --date=short
    # a verbose ls, shows changed files too
    lsv = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --decorate --date=short --numstat

    # List contributors with number of commits
    contributors = shortlog --summary --numbered

    # from mathiasbynens dotfiles:
    # Find branches containing commit
    findcommitinbranches = "!f() { git branch -a --contains $1; }; f"

    # Find tags containing commit
    findcommitintags = "!f() { git describe --always --contains $1; }; f"

    # Find commits by source code
    findcommitswithsourcecode = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short -S$1; }; f"

    # Find commits by commit message
    findcommitswithcommitmessage = "!f() { git log --pretty=format:'%C(yellow)%h  %Cblue%ad  %Creset%s%Cgreen  [%cn] %Cred%d' --decorate --date=short --grep=$1; }; f"

    # some resets without explanation
    r = reset
    r1 = reset HEAD^
    r2 = reset HEAD^^
    rh = reset --hard
    rh1 = reset HEAD^ --hard
    rh2 = reset HEAD^^ --hard

    # basic shortcuts
    cp = cherry-pick
    s = status
    cl = clone
    ci = commit
    co = checkout
    br = branchÂ·
    diff = difftool -y -x "colordiff -y " | less -R
    d = diff
    dc = diff --cached
    ds = diff --staged

    # stash shortcuts
    sl = stash list
    sa = stash apply
    ss = stash save
    clone = clone --recursive

    # Show verbose output about tags, branches or remotes
    tags = tag -l
    branches = branch -a
    remotes = remote -v

    # Show latest commits since last pull from remote
    news = log -p HEAD@{1}..HEAD@{0}

    # Submodule related
    sdiff = !git diff && git submodule foreach 'git diff'
    spush = push --recurse-submodules=on-demand
    supdateall = submodule foreach git pull

    ref-push = push origin HEAD:refs/for/master

    # Prune all stale remote branches not found locally
    prune-all-remote-branches = !git remote | xargs -n 1 git remote prune

    # Prune all local branches not found remotely. Accepts as argument the name
    # of the default (otherwise assumes it's master)
    prune-all-local-branches = "!f() { git branch --merged ${1-master} | grep -v " ${1-master}$" | xargs -r git branch -d; }; f"

    # Untrack a file
    untrack = rm --cache --
[push]
    default = current
[status]
    branch = true
    displayCommentPrefix = true
    relativePaths = false
    submodulesummary = true
[merge]
        log = true
[include]
    path = .gitconfig.user
[core]
    excludesfile = ~/.gitignore_global
    editor = vim
    autocrlf = input
    quotepath = false

# QuickNote: To modify an old commit
# You can use git rebase
# for example, if you want to modify back to commit bbc643cd, run
#
# $ git rebase --interactive bbc643cd^
#
# In the default editor, modify 'pick' to 'edit' in the line whose commit you want to modify.
# Make your changes and then stage them with
#
# $ git add <filepattern>
#
# Now you can use
#
# $ git commit --amend
#
# to modify the commit, and after that
#
# $ git rebase --continue
#
# to return back to the previous head commit.
#
################################################
#
# QuickNote2: To cherry-pick a commit to a new branch for a separate pull request
#
# Create a branch from the SHA where the original project was forked
# $ git branch my_cherry_picked_feature 251ea14
#
# Move to the branch
# $ git checkout my_cherry_picked_feature
#
# Cherry pick the commit I want to submit as a pull request
# $ git cherry-pick 4252331
#
# Push the branch and do the pull request from the head of the new branch
# $ git push origin my_cherry_picked_feature
#
