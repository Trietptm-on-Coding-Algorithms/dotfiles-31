#!/usr/bin/env bash

duplicity_backup() {
    (( $UID )) && { echo 'you need to be root to run this script'; return 1; }
    [[ "$#" -lt 2 ]] && \
        echo -e  "Usage: Call with 'duplicity_backup --exclude-globbing-filelist [excludefilelist (text file)] [src] [dst]'\n" \
            "    Note: use 'duplicity_backup -v8 ' and as [dst] -> gdocs://YOURGOOGLEACCOUNT@gmail.com/backup'\n" \
            "          for GDrive backup (requires python2-gdata package)" && \
            return 0;

    echo "Saving installed packages to $HOME/(aur)pkglist.txt"

    pacman -Qqen > $HOME/pkglist.txt
    pacman -Qqem > $HOME/aurpkglist.txt
    /usr/lib/systemd/scripts/pakbak
    duplicity "$@"
}

# Quick function that:
# Generates an ssh key
# Saves it in the proper subfolder
# Adds the key agent to the ssh-ident config
# Adds the extra config to ssh's config file
# Copies the pub key to the remote server
ssh-keygen-setup() {
    echo "Usage: call with 'ssh-keygen-setup aliasname hostname user port'"
    aliasname=$1
    hostname=$2
    user=$3
    port=$4
    keyname="id_rsa_$aliasname"
    keydir=$HOME/.ssh/identities/$aliasname/
    ssh-keygen-rsa $keyname
    mkdir -p $keydir
    mv $keyname $keydir
    mv $keyname".pub" $keydir
    # prepend the new identity entry to ssh-ident config when you find the "]" character
    sed -i "/\]/i \ \ \ \ \ \ \ \ (r\"$aliasname\",\"$aliasname\")," $HOME/.ssh/ssh-ident-config
    printf '%s\n    %s\n    %s\n    %s\n    %s\n    %s\n' "Host $aliasname" "HostName $hostname" "User $user" "Port $port" "IdentityFile $keydir$keyname" "IdentitiesOnly yes" >> $HOME/.ssh/config
    chmod 0700 $keydir
    chmod 0600 $keydir/*
    ssh-copy-id -p $port -i $keydir$keyname".pub" $user@$hostname
}

# better colors for man pages
man() {
        env \
                LESS_TERMCAP_mb=$(printf "\e[1;31m") \
                LESS_TERMCAP_md=$(printf "\e[1;31m") \
                LESS_TERMCAP_me=$(printf "\e[0m") \
                LESS_TERMCAP_se=$(printf "\e[0m") \
                LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
                LESS_TERMCAP_ue=$(printf "\e[0m") \
                LESS_TERMCAP_us=$(printf "\e[1;32m") \
                        man "$@"
}

extract() {
    local c e i

    (($#)) || return

    for i; do
        c=''
        e=1

        if [[ ! -r $i ]]; then
            echo "$0: file is unreadable: \`$i'" >&2
            continue
        fi

        case $i in
                *.tar.bz2) c='tar xvjf $1' ;;
                *.tar.gz) c='tar xvzf $1' ;;
                *.tar) c='tar xvf $1' ;;
                *.tbz2) c='tar xvjf $1' ;;
                *.tgz) c='tar xvzf $1' ;;
                *.7z)  c='7z x';;
                *.Z)   c='uncompress';;
                *.bz2) c='bunzip2';;
                *.exe) c='cabextract';;
                *.gz)  c='gunzip';;
                *.exe) c='cabextract';;
                *.lzma) c='unlzma';;
                *.tar.xz) c='tar xvJf';;
                *.rar) c='unrar x';;
                *.xz)  c='unxz';;
                *.zip) c='unzip';;
                *)     echo "$0: unrecognized file extension: \`$i'" >&2
                    continue;;
        esac

        command $c "$i"
        e=$?
    done

    return $e
}

path_prepend() {
    if test -d "$1"; then
        PATH="$1:$PATH"
    fi
}

path_append() {
    if test -d "$1"; then
        PATH="$PATH:$1"
    fi
}

mkcd() {
    mkdir -p "$1"
    builtin cd "$1"
}

# right align text and echo it; helper function for _truncated_ls
_right_align() {
    local PADDING=$(($COLUMNS - $(builtin echo "$1" | wc --chars)))
    if [[ $PADDING -gt 0 ]]; then
        for i in {1..$PADDING}; do
            builtin echo -n " "
        done
    fi
    builtin echo "$1"
}

# a pretty ls truncated to at most N lines; helper function for cd, popd, pushd
_truncated_ls() {
    local LS_LINES=25 # use no more than N lines for ls output
    local RESERVED_LINES=1 # reserve N lines of the term, for short windows
    # eg. if a window is only 8 lines high, we want to avoid filling up the
    # whole screen, so instead only 3 lines would be consumed.

    # if using all N lines makes us go over the reserved number of lines
    if [[ $(($LINES - $RESERVED_LINES)) -lt $LS_LINES ]]; then
        local LS_LINES=$(($LINES - $RESERVED_LINES))
    fi

    # compute and store the result of ls
    local RAW_LS_OUT="$(ls -lha -r -lhaF --group-directories-first \
                                   --color=always \
                                   --width=$COLUMNS)"
    local RAW_LS_LINES=$(builtin echo -E "$RAW_LS_OUT" | wc -l)

    if [[ $RAW_LS_LINES -gt $LS_LINES ]]; then
        builtin echo -E "$RAW_LS_OUT" | tail -n $(($LS_LINES - 1))
        _right_align "... $(($RAW_LS_LINES - $LS_LINES + 1)) lines hidden"
    else
        builtin echo -E "$RAW_LS_OUT"
    fi
}


